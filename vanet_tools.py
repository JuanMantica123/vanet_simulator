import pandas as pd
import matplotlib.pyplot as plt
import logging 
from scipy.spatial import distance
from collections import defaultdict
from math import sqrt
from multiprocessing.dummy import Pool as ThreadPool 
import numpy as np

def plot_microclouds(microcloud_coords,microcloud_range,coords_x,coords_y):
    fig, ax = plt.subplots()
    plt.scatter(coords_x,coords_y,c='red')
    plt.xlabel("x coordinate")
    plt.ylabel("y coordinate")
    plt.title("microclouds")
    for microcloud_coord in microcloud_coords:
        microcloud = plt.Circle(microcloud_coord,microcloud_range)
        ax.add_artist(microcloud)
    plt.show()

class Block:
    def __init__(self,identifier,size):
        self.identifier = identifier
        self.size = size
    def __eq__(self, other):
        return other and self.identifier == other.identifier

class Microcloud:
    def __init__(self,id_,x,y,ant_range,blocks,bandwith):
        self.id = id_
        self.x,self.y = x,y
        self.ant_range = ant_range
        self.blocks = blocks
        self.bandwith = bandwith
        
    def in_range(self,other_x,other_y):
        return distance.euclidean((self.x,self.y), (other_x,other_y))<=self.ant_range
    
    def has_block(self, block):
        return block in self.blocks
    
    def get_data(self):
        return self.bandwith
class Node:
    def __init__(self,df,blocks):
        self.id = df.iloc[0]['vehicle_id'] #Note that the id of the node is taken from the df generated by sumo
        self.df = df
        self.blocks = blocks[:]
        self.blocks_progress = [0 for n in range(len(blocks))]
        #Note the one to one relationship between block and microcloud
        self.microcloud_to_block = defaultdict(lambda:-1)
        self.blocks_downloaded = 0
    
    def find_block(self,microcloud):
        for index,block in enumerate(self.blocks):
            block_progress = self.blocks_progress[index] 
            if microcloud.has_block(block) and block_progress<block.size: #i.e the block has not been downloaded
                return index
        return -1
    
    def download_block(self,x,y,microcloud):
        if not microcloud.in_range(x,y):
            block_index = self.microcloud_to_block[microcloud]
            if block_index!=-1:
                block,progress = self.blocks[block_index],self.blocks_progress[block_index]
                debug= "Stopping download for block {} on car {} with microcloud {}, last progress : {}".format(block.identifier,self.id,microcloud.id,progress)
                logging.debug(debug)
                self.microcloud_to_block[microcloud], self.blocks_progress[block_index] = -1,0
        elif self.microcloud_to_block[microcloud]==-1:
            block_index = self.find_block(microcloud)
            block = self.blocks[block_index]
            if block_index!=-1:
                debug= "Initiated download for block {} on car {} with microcloud {}".format(block.identifier,self.id,microcloud.id)
                logging.debug(debug)
                self.microcloud_to_block[microcloud]= block_index
        else:
            block_index = self.microcloud_to_block[microcloud]
            self.blocks_progress[block_index]+=microcloud.get_data()
            block,progress = self.blocks[block_index],self.blocks_progress[block_index]
            debug= "Continuing download for block {} on car {} with microcloud {} latest progress: {}".format(block.identifier,self.id,microcloud.id,progress)
            logging.debug(debug)
            if progress>=block.size:
                debug= "Download finished for block {} on car {} with microcloud {}".format(block.identifier,self.id,microcloud.id)
                logging.debug(debug)
                self.microcloud_to_block[microcloud]=-1        
                self.blocks_downloaded+=1
    
    def simulate(self,microclouds):
        logging.debug("Id {}".format(self.id))
        for index, row in self.df.iterrows():
            x,y,time = row['vehicle_x'],row['vehicle_y'],row['timestep_time']
            logging.debug("Time {}".format(time))
            for microcloud in microclouds:
                self.download_block(x,y,microcloud)
        return [self.id, self.blocks_downloaded,len(self.blocks)]